<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Solutions on DenysG的个人博客</title>
    <link>https://48474.net/tags/solutions/</link>
    <description>Recent content in Solutions on DenysG的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Jan 2017 13:18:39 +0800</lastBuildDate>
    
	<atom:link href="https://48474.net/tags/solutions/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>VPS Debian8 删除一些没用的服务的方法</title>
      <link>https://48474.net/post/vps_debian_unremove_service/</link>
      <pubDate>Mon, 16 Jan 2017 13:18:39 +0800</pubDate>
      
      <guid>https://48474.net/post/vps_debian_unremove_service/</guid>
      <description>本人喜欢使用linux的debian发行版本。也用过其他的发行版本。
现在使用的vps是ufovps出售的香港云服务器。
安装的是linux的Debian8版本。
安装好后远程登陆vps后查看有如下几个服务已经安装并在运行。
  exim4 rpcbind nfs+portmap   以上这些服务我都不使用，需要关闭。方法如下：
删除 exim4 服务 exim4服务 开放 port :25 大家都知道这个端口做啥都吧！
$ apt-get purge --auto-remove exim4 exim4-base exim4-config exim4-daemon-light $ rm -rf /var/log/exim4/  删除 rpcbind 服务 rpcbind 服务 此服务开启port :111 这个端口。
$ apt-get purge --auto-remove rpcbind  删除nfs服务 $ apt-get purge --auto-remove nfs-kernel-server nfs-common portmap  如果不删除只是关闭相关服务，可以如下执行
$ systemctl disable nfs-common $ systemctl disable rpcbind $ systemctl disable exim4 $ systemctl stop nfs-common $ systemctl stop rpcbind $ systemctl stop exim4   PS：几句废话。</description>
    </item>
    
    <item>
      <title>Error: /usr/local must be writable! 解决方法</title>
      <link>https://48474.net/post/brew_update_error_fix/</link>
      <pubDate>Mon, 26 Dec 2016 12:51:15 +0800</pubDate>
      
      <guid>https://48474.net/post/brew_update_error_fix/</guid>
      <description>今天在Mac下执行brew update时出现以下错误提示：
 $ brew update
Error: /usr/local must be writable!
 以前一直默认用的好好的,突然出现这种情况导致不能正常使用了。 按我习惯性的方法，修改下目录的权限吧
 $ sudo chmod -R g+w /usr/local
$ brew update
还是出现错误提示 Error: /usr/local must be writable!
 有点晕啦，怎么还是有问题呢？ 仔细想了下，自检以下吧。
 $ brew doctor
 上面是修改目录的写权限，现在修改目录的用户权限吧！！
 $ sudo chown -R $(whoami) /usr/local
 再次执行brew doctor, 正常啦！！！
再次执行brew update, 终于正常，正常啦！！！
总结一下：
 升级了macos后没执行brew doctor，导致brew 出现问题。
 升级系统，一定要检测下第三方软件是否能正常工作。
 检测工作没执行到底呀。  </description>
    </item>
    
    <item>
      <title>CaddyServer使用记录</title>
      <link>https://48474.net/post/caddy-guide/</link>
      <pubDate>Thu, 22 Dec 2016 14:37:00 +0800</pubDate>
      
      <guid>https://48474.net/post/caddy-guide/</guid>
      <description>Caddy是一个Golang编写的服务器软件，官方的宣传语“The HTTP/2 web server with automatic HTTPS”以及“Serve The Web Like It&amp;rsquo;s 2016”简明表达了这个软件的优点和趋势，它拥有Apache或者Nginx所具有的web server模块，同时还有一些很有特色的功能，比如:
 HTTP/2 Automatic HTTPS Multi-core Websockets Markdown IPv6 Git FastCGI &amp;hellip;  在去年就开始使用Caddy，它提供的便捷配置，部署了内部测试服务的Web服务器、个人网站的Web服务器。配置项的语法简单粗暴，非常简洁明了。比nginx简单多了。
下面举几个例子：
 简单的测试网站
  :8530 { root /var/www/test_site }   使用git同步测试环境
  :8530 { root /var/www/test_site/public git git.int5262.com/user_name/project_name { path ../ interval 60 } fastcgi / 127.0.0.1:9001 php }   站点跳转
  http://48474.com, http://www.48474.com { redir https://48474.com{uri} }  看看吧，是不是太简单了？ 配置起来能具体到简洁到哭的指令。 详细文档请看官方的User Guide。</description>
    </item>
    
    <item>
      <title>Golang程序配置方案小结</title>
      <link>https://48474.net/post/config-solutions-for-golang-app/</link>
      <pubDate>Sat, 10 Oct 2015 13:44:31 +0800</pubDate>
      
      <guid>https://48474.net/post/config-solutions-for-golang-app/</guid>
      <description>在Twitter上看到一篇关于Golang程序配置方案总结的系列文章（一个mini series，共6篇），原文链接：在这里。我觉得不错，这里粗略整理（非全文翻译）一下，供大家参考。
一、背景 无论使用任何编程语言开发应用，都离不开配置数据。配置数据提供的形式有多样，不外乎命令行选项(options)、参数（parameters)，环境变量（envvars)以及配置文件等。Golang也不例外。Golang内置flag标准库，可以用来支持部分命令行选项和参数的解析；Golang通过os包提 供的方法可以获取当前环境变量；但Golang没有规定标准配置文件格式(虽说内置支持xml、json)，多通过第三方 包来解决配置文件读取的问题。Golang配置相关的第三方包很多，作者在本文中给出的配置方案中就包含了主流的第三方配置数据操作包。
文章作者认为一个良好的应用配置层次应该是这样的：
 程序内内置配置项的初始默认值 配置文件中的配置项值可以覆盖(override)程序内配置项的默认值。 命令行选项和参数值具有最高优先级，可以override前两层的配置项值。  下面就按作者的思路循序渐进探讨golang程序配置方案。
二、解析命令行选项和参数 这一节关注golang程序如何访问命令行选项和参数。
golang对访问到命令行参数提供了内建的支持：
//cmdlineargs.go package main import ( // &amp;quot;fmt&amp;quot; &amp;quot;os&amp;quot; &amp;quot;path/filepath&amp;quot; ) func main() { println(&amp;quot;I am &amp;quot;, os.Args[0]) baseName := filepath.Base(os.Args[0]) println(&amp;quot;The base name is &amp;quot;, baseName) // The length of array a can be discovered using the built-in function len println(&amp;quot;Argument # is &amp;quot;, len(os.Args)) // the first command line arguments if len(os.Args) &amp;gt; 1 { println(&amp;quot;The first command line argument: &amp;quot;, os.</description>
    </item>
    
  </channel>
</rss>